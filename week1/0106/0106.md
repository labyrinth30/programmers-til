[오늘 실습한 깃허브 링크에요](https://github.com/labyrinth30/git-practice)
# 브랜치 전략과 병합, 충돌 해결하기

오늘은 브랜치를 어떻게 사용하면 좋을지, 네이밍과 깃 플로우, 병합과 PR에 대해 배워볼 것이에요.
## 📖 브랜치 전략 (네이밍, Git flow)
브랜치의 이름은 해당 브랜치에서 하고자 하는 것을 명확히 나타내야해요
* main : 최종적으로 배포되는 버전을 관리하는 신성한 브랜치에요
* develop : 실질적인 개발 브랜치의 중심인 마더 브랜치로, 구현할 기능을 브랜치로 뻗어나갈 때 이 브랜치를 기준으로 브랜치를 파야해요.
  또한 구현한 기능들을 이 곳 devlop 브랜치로 병합하고, main 브랜치로 가기 전 최종 테스트를 하는 곳이에요
* feature / hotfix / refactor 등등
  각각 깃허브에서 이슈잉한 것들을 CC해서 담당하는 브랜치에요
  예를 들어 로그인 구현이 이슈 번호 4번이라면, `feature/#4` 처럼 브랜치를 파서 개발해요.

## Merge의 여러 방법들
### Fast-Forward
**"뒤처져 있던 브랜치가 앞서 나간 브랜치의 위치로 이동하는 것"**을 말해요.
![](https://velog.velcdn.com/images/ayeon0/post/7ba1e118-c498-4a50-93fd-0c437ad89932/image.png)
main 브랜치에서 feature 브랜치를 만들어서 작업을 하고 있었다고 가정해볼게요
feature에서 커밋하는 동안, main 브랜치에는 아무런 새로운 커밋이 생기지 않았어요.
이 상태에서 머지를 하면, Git은 별도의 새로운 커밋 없이 그냥 main의 head를 feature 브랜치 head의 위치로 옮겨요!

![](https://velog.velcdn.com/images/ayeon0/post/eb58fa7f-1183-40e6-ab03-7db17993bed3/image.png)
* main 브랜치는 직접 push 하지말고 다음과 같이 fast-forward 커밋만 가능하도록 하는 게 좋아요.

### 3-Way-Merge
![](https://velog.velcdn.com/images/ayeon0/post/080264cf-fca2-4ac1-a331-fe470f782f7a/image.png)
* 깃 실습하면서 작성한 커밋들이에요.
  두 브랜치 모두 새 커밋이 생겼을 때 쓰여요.
  기존 Fast Forward 과 달리 두 브랜치의 변경 사항을 하나로 합치는 커밋이 생겨요
```
git merge {병합할 브랜치명}
```

### 번외편: 스쿼시 머지
여러 개의 자잘한 커밋들을 꽉 눌러서 '커다란 커밋 하나'로 합쳐버리는 기능이에요

*   **3-way-머지:** 10개의 자잘한 커밋이 메인 브랜치로 그대로 병합돼요. (로그가 길고 복잡해짐)
*   **스쿼시 머지:** 작업한 10개의 커밋을 통째로 깔끔한 커밋 1개로 만들어서 병합해요.

다음과 같은 장점이 있어요
스쿼시 머지를 쓰면 **의미 있는 기능 단위**로만 기록이 남아서 보기에 아주 편안해져요.
만약 해당 구현사항을 되돌려야해도 하나로 합쳐진 **그 커밋 하나만 revert**하면 되니까 번거롭지 않아요.

AI가 다음과 같은 비유로 설명해줬어요.
시장에서 장을 본다고 생각해 봐요!
*   **그냥 머지:** 사과 한 알 사고 영수증 끊고, 대파 한 단 사고 영수증 끊고... 영수증이 10장이 돼요.
*   **스쿼시 머지:** 장바구니에 다 담은 다음에 마지막에 계산대에서 **"식재료 10종 구매"**라고 적힌 영수증 딱 한 장만 받는 거예요.


## Pull Request
![](https://velog.velcdn.com/images/ayeon0/post/1ef00a21-f1dd-4dbe-b145-20f517149c46/image.png)
우선 `pull-request-test` 라는 브랜치를 만든 후 `origin/pull-request-test`로 커밋을 푸쉬해봤어요.
![](https://velog.velcdn.com/images/ayeon0/post/56bf36a7-1adb-4cfc-ae2a-53ef2300a2cf/image.png)
노란색으로 새로운 브랜치에서 `push`가 들어왔다고 알림이 왔어요. 눌러봅시다.
![](https://velog.velcdn.com/images/ayeon0/post/2e64fb87-76e9-4183-a9fb-36da1804bea6/image.png)
해당 pr이 했던 것을 깔끔하게 작성해서 pr을 생성해줍시다.
![](https://velog.velcdn.com/images/ayeon0/post/a2f0f4a0-0bb7-49d4-aa1c-7a2c5916e2cd/image.png)
pr를 생성하면 깃허브에서 충돌이 나지 않나 확인해봐요
* 저는 코드래빗을 추가해서 자동으로 pr를 리뷰하게 해줬어요.
  ![](https://velog.velcdn.com/images/ayeon0/post/133368b3-51f9-43ab-8015-c5356f2e94d6/image.png)
* 다음과 같이 3-way-머지, 스쿼지머지, 리베이스 중 어떤 걸로 병합할 건지 선택하게 할 수도 있어요.
  ![](https://velog.velcdn.com/images/ayeon0/post/b180994b-848a-4752-812c-99b5271db85b/image.png)
  병합 후 해당 브랜치를 삭제했어요.
```
git fetch -p (prune)
``` 
원격 레포에 없지만 로컬에 남아있는 브랜치들을 이 명령어로 없애줄 수 있어요.
![](https://velog.velcdn.com/images/ayeon0/post/911a5c4a-88a1-4b3d-9782-a8891e7b230b/image.png)

## Merge Conflict
방금 병합은 충돌이 나지 않았지만, 만약 병합하려는 두 커밋이 같은 파일을 건드렸으면 어떻게 될까요?
`pull-request-test` 브랜치에서 `programmers.yaml`을 수정하고, 병합하고 싶은 `main` 브랜치에서도 `programmers.yaml`을 수정해봤어요.

![](https://velog.velcdn.com/images/ayeon0/post/bb7f1906-8c91-44bb-8173-3a7128f9069d/image.png)
이번에는 충돌이 있어서 수동으로 병합을 해줘야 해요
![](https://velog.velcdn.com/images/ayeon0/post/c0431e0e-977f-401f-a86d-6b3586d40ffe/image.png)
이 중에서 어떤 코드를 사용할 건지 직접 에디터로 수정해줄거에요
![](https://velog.velcdn.com/images/ayeon0/post/d105bc77-22a2-4600-95ef-d383d1e50d38/image.png)
저는 이렇게 남기고 병합할거에요.

![](https://velog.velcdn.com/images/ayeon0/post/473e7976-ee5b-4c31-8f72-c47753efe049/image.png)
이렇게 병합된 것을 볼 수 있어요.
![](https://velog.velcdn.com/images/ayeon0/post/9c939f15-cc4f-4bdb-84b2-d626e9535ae8/image.png)
오늘 `pull request`와 `merge`를 실습하고 난 뒤의 커밋 히스토리에요.
![](https://velog.velcdn.com/images/ayeon0/post/c5d44b55-810c-4bf0-9fe2-fea14f4dcb58/image.png)
깃허브에도 커밋 히스토리가 다음과 같이 남아있어요